function PCMPlayer(option) {
    this.init(option);
}

PCMPlayer.prototype.init = function(option) {
    var defaults = { encoding: '32bitInt', channels: 2, sampleRate: 48000};
    if (this.audioCtx!=undefined){
        this.audioCtx.close();
        this.audioCtx = null;
        console.log('flush audio player !!!')
    }
    this.option = Object.assign({}, defaults, option);
    this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    this.audioCtx.resume();
    this.audioCtx.onstatechange = () => console.log("AudioContext:", this.audioCtx.state);
    this.startTime = this.audioCtx.currentTime;
    this.maxValue = this.getMaxValue();
    this.typedArray = this.getTypedArray();
};

PCMPlayer.prototype.getTypedArray = function () {
    var typedArrays = {
        '8bitInt': Int8Array,
        '16bitInt': Int16Array,
        '32bitInt': Int32Array,
        '32bitFloat': Float32Array
    }
    return typedArrays[this.option.encoding] ? typedArrays[this.option.encoding] : typedArrays['16bitInt'];
};

PCMPlayer.prototype.getMaxValue = function () {
    var encodings = {
        '8bitInt': 128,
        '16bitInt': 32768,
        '32bitInt': 2147483648,
        '32bitFloat': 1
    }
    return encodings[this.option.encoding] ? encodings[this.option.encoding] : encodings['16bitInt'];
};

PCMPlayer.prototype.getFormatedValue = function(data) {
    var data = new this.typedArray(data.buffer),
        float32 = new Float32Array(data.length),
        i;
    for (i = 0; i < data.length; i++) {
        float32[i] = data[i] / this.maxValue;
    }
    return float32;
};

PCMPlayer.prototype.feed = function(data) {
    if (data.every(item=>item===0)) return;
    if (this.startTime - this.audioCtx.currentTime>=0.07) return;
    if (this.option.encoding !='32bitFloat'){
        data = this.getFormatedValue(data)
    }
    bufferSource = this.audioCtx.createBufferSource();
    length = data.length / this.option.channels;
    audioBuffer = this.audioCtx.createBuffer(this.option.channels, length, this.option.sampleRate);
    for (channel = 0; channel < this.option.channels; channel++) {
        audioData = audioBuffer.getChannelData(channel);
        offset = channel;
        for (i = 0; i < length; i++) {
            audioData[i] = data[offset];
            offset += this.option.channels;
        }
    }
    console.log('start vs current '+this.startTime+' vs '+this.audioCtx.currentTime+' duration: '+audioBuffer.duration);
    if (this.startTime < this.audioCtx.currentTime) {
        this.startTime = this.audioCtx.currentTime;
    }
    bufferSource.buffer = audioBuffer;
    bufferSource.connect(this.audioCtx.destination);
    bufferSource.start(this.startTime);
    this.startTime += audioBuffer.duration;
};

PCMPlayer.prototype.destroy = function() {
    this.audioCtx.close();
};
